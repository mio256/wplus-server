// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.25.0
// source: work_entries.sql

package rdb

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createWorkEntry = `-- name: CreateWorkEntry :one
insert into work_entries (employee_id, workplace_id, date, hours, start_time, end_time, attendance, comment)
values ($1, $2, $3, $4, $5, $6, $7, $8)
returning id, employee_id, workplace_id, date, hours, start_time, end_time, attendance, comment, deleted_at, created_at, updated_at
`

type CreateWorkEntryParams struct {
	EmployeeID  int64       `json:"employee_id"`
	WorkplaceID int64       `json:"workplace_id"`
	Date        pgtype.Date `json:"date"`
	Hours       pgtype.Int2 `json:"hours"`
	StartTime   pgtype.Time `json:"start_time"`
	EndTime     pgtype.Time `json:"end_time"`
	Attendance  pgtype.Bool `json:"attendance"`
	Comment     pgtype.Text `json:"comment"`
}

func (q *Queries) CreateWorkEntry(ctx context.Context, arg CreateWorkEntryParams) (WorkEntry, error) {
	row := q.db.QueryRow(ctx, createWorkEntry,
		arg.EmployeeID,
		arg.WorkplaceID,
		arg.Date,
		arg.Hours,
		arg.StartTime,
		arg.EndTime,
		arg.Attendance,
		arg.Comment,
	)
	var i WorkEntry
	err := row.Scan(
		&i.ID,
		&i.EmployeeID,
		&i.WorkplaceID,
		&i.Date,
		&i.Hours,
		&i.StartTime,
		&i.EndTime,
		&i.Attendance,
		&i.Comment,
		&i.DeletedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getWorkEntriesByEmployee = `-- name: GetWorkEntriesByEmployee :many
select id, employee_id, workplace_id, date, hours, start_time, end_time, attendance, comment, deleted_at, created_at, updated_at from work_entries where employee_id = $1 and deleted_at is null
`

func (q *Queries) GetWorkEntriesByEmployee(ctx context.Context, employeeID int64) ([]WorkEntry, error) {
	rows, err := q.db.Query(ctx, getWorkEntriesByEmployee, employeeID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []WorkEntry
	for rows.Next() {
		var i WorkEntry
		if err := rows.Scan(
			&i.ID,
			&i.EmployeeID,
			&i.WorkplaceID,
			&i.Date,
			&i.Hours,
			&i.StartTime,
			&i.EndTime,
			&i.Attendance,
			&i.Comment,
			&i.DeletedAt,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getWorkEntriesByOffice = `-- name: GetWorkEntriesByOffice :many
select work_entries.id, employee_id, workplace_id, date, hours, start_time, end_time, attendance, comment, work_entries.deleted_at, work_entries.created_at, work_entries.updated_at, workplaces.id, workplaces.name, office_id, work_type, workplaces.deleted_at, workplaces.created_at, workplaces.updated_at, offices.id, offices.name, offices.deleted_at, offices.created_at, offices.updated_at
from work_entries
join workplaces on work_entries.workplace_id = workplaces.id
join offices on workplaces.office_id = offices.id
where offices.id = $1 and work_entries.deleted_at is null
`

type GetWorkEntriesByOfficeRow struct {
	ID          int64            `json:"id"`
	EmployeeID  int64            `json:"employee_id"`
	WorkplaceID int64            `json:"workplace_id"`
	Date        pgtype.Date      `json:"date"`
	Hours       pgtype.Int2      `json:"hours"`
	StartTime   pgtype.Time      `json:"start_time"`
	EndTime     pgtype.Time      `json:"end_time"`
	Attendance  pgtype.Bool      `json:"attendance"`
	Comment     pgtype.Text      `json:"comment"`
	DeletedAt   pgtype.Timestamp `json:"deleted_at"`
	CreatedAt   pgtype.Timestamp `json:"created_at"`
	UpdatedAt   pgtype.Timestamp `json:"updated_at"`
	ID_2        int64            `json:"id_2"`
	Name        string           `json:"name"`
	OfficeID    int64            `json:"office_id"`
	WorkType    WorkType         `json:"work_type"`
	DeletedAt_2 pgtype.Timestamp `json:"deleted_at_2"`
	CreatedAt_2 pgtype.Timestamp `json:"created_at_2"`
	UpdatedAt_2 pgtype.Timestamp `json:"updated_at_2"`
	ID_3        int64            `json:"id_3"`
	Name_2      string           `json:"name_2"`
	DeletedAt_3 pgtype.Timestamp `json:"deleted_at_3"`
	CreatedAt_3 pgtype.Timestamp `json:"created_at_3"`
	UpdatedAt_3 pgtype.Timestamp `json:"updated_at_3"`
}

func (q *Queries) GetWorkEntriesByOffice(ctx context.Context, id int64) ([]GetWorkEntriesByOfficeRow, error) {
	rows, err := q.db.Query(ctx, getWorkEntriesByOffice, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetWorkEntriesByOfficeRow
	for rows.Next() {
		var i GetWorkEntriesByOfficeRow
		if err := rows.Scan(
			&i.ID,
			&i.EmployeeID,
			&i.WorkplaceID,
			&i.Date,
			&i.Hours,
			&i.StartTime,
			&i.EndTime,
			&i.Attendance,
			&i.Comment,
			&i.DeletedAt,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ID_2,
			&i.Name,
			&i.OfficeID,
			&i.WorkType,
			&i.DeletedAt_2,
			&i.CreatedAt_2,
			&i.UpdatedAt_2,
			&i.ID_3,
			&i.Name_2,
			&i.DeletedAt_3,
			&i.CreatedAt_3,
			&i.UpdatedAt_3,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const softDeleteWorkEntriesByEmployee = `-- name: SoftDeleteWorkEntriesByEmployee :exec
update work_entries set deleted_at = now() where employee_id = $1 and deleted_at is null
`

func (q *Queries) SoftDeleteWorkEntriesByEmployee(ctx context.Context, employeeID int64) error {
	_, err := q.db.Exec(ctx, softDeleteWorkEntriesByEmployee, employeeID)
	return err
}

const softDeleteWorkEntry = `-- name: SoftDeleteWorkEntry :exec
update work_entries set deleted_at = now() where id = $1
`

func (q *Queries) SoftDeleteWorkEntry(ctx context.Context, id int64) error {
	_, err := q.db.Exec(ctx, softDeleteWorkEntry, id)
	return err
}
