// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.25.0
// source: work_entries.sql

package rdb

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createWorkEntry = `-- name: CreateWorkEntry :one
insert into work_entries (employee_id, workplace_id, date, hours, start_time, end_time, attendance, comment)
values ($1, $2, $3, $4, $5, $6, $7, $8)
returning id, employee_id, workplace_id, date, hours, start_time, end_time, attendance, comment, deleted_at, created_at, updated_at
`

type CreateWorkEntryParams struct {
	EmployeeID  int64       `json:"employee_id"`
	WorkplaceID int64       `json:"workplace_id"`
	Date        pgtype.Date `json:"date"`
	Hours       pgtype.Int2 `json:"hours"`
	StartTime   pgtype.Time `json:"start_time"`
	EndTime     pgtype.Time `json:"end_time"`
	Attendance  pgtype.Bool `json:"attendance"`
	Comment     pgtype.Text `json:"comment"`
}

func (q *Queries) CreateWorkEntry(ctx context.Context, arg CreateWorkEntryParams) (WorkEntry, error) {
	row := q.db.QueryRow(ctx, createWorkEntry,
		arg.EmployeeID,
		arg.WorkplaceID,
		arg.Date,
		arg.Hours,
		arg.StartTime,
		arg.EndTime,
		arg.Attendance,
		arg.Comment,
	)
	var i WorkEntry
	err := row.Scan(
		&i.ID,
		&i.EmployeeID,
		&i.WorkplaceID,
		&i.Date,
		&i.Hours,
		&i.StartTime,
		&i.EndTime,
		&i.Attendance,
		&i.Comment,
		&i.DeletedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getWorkEntriesByEmployee = `-- name: GetWorkEntriesByEmployee :many
select id, employee_id, workplace_id, date, hours, start_time, end_time, attendance, comment, deleted_at, created_at, updated_at from work_entries where employee_id = $1 and deleted_at is null
`

func (q *Queries) GetWorkEntriesByEmployee(ctx context.Context, employeeID int64) ([]WorkEntry, error) {
	rows, err := q.db.Query(ctx, getWorkEntriesByEmployee, employeeID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []WorkEntry
	for rows.Next() {
		var i WorkEntry
		if err := rows.Scan(
			&i.ID,
			&i.EmployeeID,
			&i.WorkplaceID,
			&i.Date,
			&i.Hours,
			&i.StartTime,
			&i.EndTime,
			&i.Attendance,
			&i.Comment,
			&i.DeletedAt,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const softDeleteWorkEntry = `-- name: SoftDeleteWorkEntry :exec
update work_entries set deleted_at = now() where id = $1
`

func (q *Queries) SoftDeleteWorkEntry(ctx context.Context, id int64) error {
	_, err := q.db.Exec(ctx, softDeleteWorkEntry, id)
	return err
}
