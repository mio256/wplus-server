// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.25.0
// source: for_output.sql

package rdb

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const outputWorkEntriesByWorkplaceAndDate = `-- name: OutputWorkEntriesByWorkplaceAndDate :many
select employees.name as employee_name, work_entries.id, work_entries.employee_id, work_entries.workplace_id, work_entries.date, work_entries.hours, work_entries.start_time, work_entries.end_time, work_entries.attendance, work_entries.comment, work_entries.deleted_at, work_entries.created_at, work_entries.updated_at
from work_entries
    join employees on work_entries.employee_id = employees.id
    join workplaces on work_entries.workplace_id = workplaces.id
where workplaces.id = $1
    and work_entries.date >= $2
    and work_entries.date <= $3
    and work_entries.deleted_at is null
order by employee_name
`

type OutputWorkEntriesByWorkplaceAndDateParams struct {
	ID      int64       `json:"id"`
	MinDate pgtype.Date `json:"min_date"`
	MaxDate pgtype.Date `json:"max_date"`
}

type OutputWorkEntriesByWorkplaceAndDateRow struct {
	EmployeeName string           `json:"employee_name"`
	ID           int64            `json:"id"`
	EmployeeID   int64            `json:"employee_id"`
	WorkplaceID  int64            `json:"workplace_id"`
	Date         pgtype.Date      `json:"date"`
	Hours        pgtype.Int2      `json:"hours"`
	StartTime    pgtype.Time      `json:"start_time"`
	EndTime      pgtype.Time      `json:"end_time"`
	Attendance   pgtype.Bool      `json:"attendance"`
	Comment      pgtype.Text      `json:"comment"`
	DeletedAt    pgtype.Timestamp `json:"deleted_at"`
	CreatedAt    pgtype.Timestamp `json:"created_at"`
	UpdatedAt    pgtype.Timestamp `json:"updated_at"`
}

func (q *Queries) OutputWorkEntriesByWorkplaceAndDate(ctx context.Context, arg OutputWorkEntriesByWorkplaceAndDateParams) ([]OutputWorkEntriesByWorkplaceAndDateRow, error) {
	rows, err := q.db.Query(ctx, outputWorkEntriesByWorkplaceAndDate, arg.ID, arg.MinDate, arg.MaxDate)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []OutputWorkEntriesByWorkplaceAndDateRow
	for rows.Next() {
		var i OutputWorkEntriesByWorkplaceAndDateRow
		if err := rows.Scan(
			&i.EmployeeName,
			&i.ID,
			&i.EmployeeID,
			&i.WorkplaceID,
			&i.Date,
			&i.Hours,
			&i.StartTime,
			&i.EndTime,
			&i.Attendance,
			&i.Comment,
			&i.DeletedAt,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
